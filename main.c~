#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "dict.h"

#define error(args...) do { fprintf (stderr, args); exit (1); } while (0)

char* readline (FILE* f);

int main (int argc, char** argv) {
  dict_t* dict = dict_create();
  while (1) {
    printf("> ");
    fflush(stdout);

    char* input = readline(stdin);

    // Destroys dictionary and exits if EOF was read
    if (input == NULL) {
      free(input);
      dict_destroy(dict);
      printf("goodbye.\n");
      break;
    }

    // Parses input to get command
    char cmd[4];
    sscanf(input, "%3s", cmd);

    // Handles execution of get command
    if (strcmp(cmd, "get") == 0) {
      char* key = input+4;
      char* val = dict_get(dict, key);

      if (val == NULL) {
        printf("\n");
      } else {
        printf("%s\n", val);
      }
    }

    // Handles execution of put command
    else if (strcmp(cmd, "put") == 0) {
      char* keyVal = input+4;             // Skips "put"
      char* colon = strchr(keyVal, ':');  // Finds ':' separating key and val

      // Handles incorrect input
      if (colon == NULL) {
        printf("Error: incorrect KEY:VALUE input\n");
        free(input);
        dict_destroy(dict);
        break;
      }

      *colon = '\0';       // Replaces colon with null terminator
      char* key = keyVal;  // Points to start of key
      char* val = colon+1; // Points to start of val

      dict_put(dict, key, val);
    }

    // Handles execution of del command
    else if (strcmp(cmd, "del") == 0) {
      char* key = input+4;
      dict_del(dict, key);
    }

    // Handles execution of clr command
    else if (strcmp(cmd, "clr") == 0 ) {
      dict_clear(dict);
    }

    // Handles execution of siz command
    else if (strcmp(cmd, "siz") == 0) {
      printf("%ld\n", dict_size(dict));
    }

    // Handles case of unknown command
    else {
      free(input);
      dict_destroy(dict);
      break;
    }

    free(input);
  }
}

#define BUFLEN 1024

char* readline (FILE* f) {
  char*  buf = NULL;
  size_t alloc_len = 0;
  ssize_t pos = -1;

  while (1) {
    int c = fgetc (f);

    if (c == EOF)
      return buf;
    ++pos;
    if (alloc_len <= pos) { // Reading one more char, and no more space.
      alloc_len += BUFLEN;
      buf = realloc (buf, alloc_len);
    }
    if (c == (int) '\n') {
      buf[pos] = 0;
      return buf;
    }
    buf[pos] = (char) c;
  }

  return buf;
}
